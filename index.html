<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="game-engine-origin" content="http://www.isogenicengine.com">
	<meta http-equiv="X-UA-Compatible" content="IE=9" >
	<title>Lizards and Meerkats</title>

	<!-- STYLES -->
	<!--<link href="css/default.css" rel="stylesheet" type="text/css" />-->
    <link href="css/custom-theme/jquery-ui-1.10.3.custom.css" rel="stylesheet">
	<link href='http://fonts.googleapis.com/css?family=Freckle+Face' rel='stylesheet' type='text/css'>

    <style>


    /* apply a natural box layout model to all elements */
    *, *:before, *:after {
        -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;
    }
	
    body {
        font-family: 'Freckle Face', cursive;
        background-color: rgb(69,51,38);
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .yellowText {
        color: #f3d35f !important;
    }

    #backgroundimage {
        background-image: url(./assets/textures/grass1.jpg);
        background-repeat: repeat;
        position: fixed;
        width: 100%;
        height: 100%;
        opacity: 0.7;
        z-index: -10;
    }

    .ui-widget {
        font-family: 'Freckle Face', cursive;
    }

    body > canvas {
        display: none;
    }

    #blocker {

        position: absolute;

        width: 100%;
        height: 100%;

        background-color: rgba(0,0,0,0.5);

        z-index: 10000;

        font-size: 1.0em;
    }

    #blocker .ui-button {
        font-size: 0.7em;
    }

    #instructions {

        width: 100%;
        height: 100%;

        display: -webkit-box;
        display: -moz-box;
        display: box;

        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;

        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;

        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;

        color: #ffffff;
        text-align: center;

        cursor: pointer;

    }

    #gameMenu {
        width: 12.5em;
        position: absolute;
        top: 9em;
        left: 50%;
        margin-left: -6.3em;
        font-size: 1em;
    }

    #spawnLink {
        font-weight: bold;
        font-size: 1.6em;
        padding-left: 1.9em;
        -webkit-text-stroke: 1.0px #600;
        -moz-text-stroke: 1.0px #600;
        text-shadow: 1px 0px 40px #CCA469;
    }

    #spawnLink.cantSpawn {
        -webkit-text-stroke: 0;
        -moz-text-stroke: 0;
        text-shadow: none;
        color: inherit !important;
    }

    #interface {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;

        z-index: 100;
    }

    #blockbar, #stambar {
        position: absolute;
        left: 50%;
        top: 50%;
        margin-left: -63px;
        margin-top: -100px;
        opacity: 0.6;
    }

    #stambar {
        margin-top: -84px;
    }

    #blockbar > * {
        position: absolute;
        left: 0px;
        right: 0px;
    }

    #blockbarInner {
        background-image: url(./assets/ui/blockbar_inner.png);
        width: 118px;
        height:31px;
        background-size: 119px 31px;
        background-repeat: no-repeat;
        position: absolute;
        left: 4px;
    }

    #stambarInner {
        background-image: url(./assets/ui/stambar_inner.png);
        width: 118px;
        height:21px;
        background-size: 119px 21px;
        background-repeat: no-repeat;
        position: absolute;
        top: 2px;
        left: 4px;
    }

    #healthbar {
        position: absolute;
        left: 50px;
        bottom: 40px;
        width: 240px;
        height: 20px;
    }
    #healthbar > * {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 240px;
        height: 100%;
        text-align: center;
        text-shadow: 0 0 0.2em #F87, 0 0 0.2em #F87;
        color: rgb(80, 9, 9);
    }

    #goldHarvestElement, .generalNotificationElement {
        color: #ffff00;
        font-weight: bold;
        font-size: 2.4em;
        position: absolute;
        text-align: center;
        top: 50%;
        width: 100%;
        margin-top: -40px;
        padding-top: 40px;
        opacity: 1;
        text-shadow: 0.05em 0.05em 0.1em rgb(122, 91, 24);
    }

    .generalNotificationElement {
        font-size: 2.4em;
        margin-top: -40px;
        top: 15%;
    }

    #statusbar {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 30px;
        background-color: rgba(153, 102, 0, .3);
        font-size: 30px;
        padding: 0px 10px;
    }

    #resource1_1, #resource1_2, #resource2_1, #resource2_2 {
        position: relative;
    }

    .resourceAddAnimElement {
        position: absolute;
        right: 0px;
        top: 30px;
        text-align: right;
        color: rgb(159, 253, 33);
    }

    #buildMenu {
        position: absolute;
        border: 1px solid #999999;
        width: 200px;
        right: 20px;
        bottom: 50px;
        display: none;
    }

    .spellSlot {
        position: relative;
        width: 50px;
        height: 50px;
        float: left;
        border: 1px solid #444444;
        text-align: center;
        font-size: 11px;
        color: #f3d35f;
    }
    .spellSlotPressed {
        border-color: #e46922;
        color: #e46922;
    }

    .keyShortcutLabel {
        position: absolute;
        right: 5px;
        bottom: 5px;
        font-size: 10px;
        color: white;
    }

    #voiceCommands {
        float: right;
        height: 100%;
        overflow: visible;
        font-size: 0.8em;
        padding: 0 0.2em;
        width: 10.5em;
    }
    #voiceCommands > div {
        background-color: rgba(153, 102, 0, .3);
        border: 1px solid rgb(153, 102, 0);
        padding: 0 0.2em;
        display: none;
    }

    #reviveCountdown {
        position: absolute;
        top: 40%;
        width: 100%;
        margin-top: -20px;
        font-size: 2em;
        color: red;
        text-align: center;
        display: none;
    }

    #minimap {
        background-image: url(./assets/heightmaps/Botswana.png);
        background-size: 100% 100%;
        position: absolute;
        left: 50%;
        top: 50%;
        margin-top: -200px;
        margin-left: -200px;
        width: 400px;
        height: 400px;
        border: 1px solid black;
        display: none;
        z-index: 100;
    }
    .minimapBuilding {
        position: absolute;
        width: 20px;
        height: 20px;
        opacity: 0.7;
        cursor: pointer;
    }
    .minimapBuilding:hover {
        opacity: 1.0;
        width: 24px;
        height: 24px;
        margin-left: -2px;
        margin-top: -2px;
        background-size: 24px 24px;
    }
    #minimapBuildingmainBuildingLizards {
        background-image: url(./assets/ui/minimap_mainBuildingLizards.png);
    }
    #minimapBuildingmainBuildingMeerkats {
        background-image: url(./assets/ui/minimap_mainBuildingMeerkats.png);
    }

    /* donation stuff */
    .lightRay {
        width: 59px;
        height: 97px;
        position: absolute;
        top: -64px;
        left: -3px;
    }
    .lightRay > div {
        background-image: url(./assets/ui/lightRaySprite.png);
        background-position: 0px 0px;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
    }
    #key_G {
        background-image: url(./assets/ui/key_G_unpressed.png);
        width: 72px;
        height: 79px;
        overflow: visible;
        position: absolute;
        top: 45%;
        right: 10%;
    }
    #goldDonationBar {
        /* Rotate div */
        transform:rotate(-90deg);
        -ms-transform:rotate(-90deg); /* IE 9 */
        -webkit-transform:rotate(-90deg); /* Opera, Chrome, and Safari */
        display: none;
        position: absolute;
        top: -30px;
        left: 10px;
        width: 240px;
        height: 20px;
    }
    #goldDonationBarOuter {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: 5;
        background-image: url(./assets/ui/progressbarOverlay.png);
    }
    #goldDonationBarInner {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: 3;
    }
    #goldDonationBarDescriptor {
        transform:rotate(90deg);
        -ms-transform:rotate(90deg); /* IE 9 */
        -webkit-transform:rotate(90deg); /* Opera, Chrome, and Safari */
        position: absolute;
        top: -50px;
        left: 0px;
        width: 50px;
        padding-top: 50px;
        z-index: 8;
        text-align: center;
        text-shadow: 1px 0px 20px red;
        -webkit-transition: width 0.3s;
        transition: width 0.3s;
        -moz-transition: width 0.3s;
        -o-transition: width 0.3s;
        -webkit-text-stroke: 1.0px #666;
        -webkit-text-fill-color: #FFFFFF;
        -moz-text-stroke: 1.0px #666;
        -moz-text-fill-color: #FFFFFF;
    }
    #goldDonationGoldFlyElement {
        position: absolute;
        left: 0px;
        top: 0px;
        visibility: hidden;
    }


    #chat {
        position: absolute;
        left: 50px;
        bottom: 100px;
        width: 300px;
        height: 150px;
        font-size: 1em;
        overflow: hidden;
    }
    #chat-content {
        width: 100%;
        position: absolute;
        bottom: 20px;
        left: 0px;
    }
    #chat-textinput {
        width: 100%;
        height: 20px;
        position: absolute;
        bottom: 0px;
        left: 0px;
        background-color: transparent;
        border: 0px;
    }
    .chat-focused {
        background-color: rgba(153, 102, 0, .3);
    }
    .chat-focused #chat-content {
        border-bottom: 1px solid rgb(153, 102, 0);
    }


    #playerList {
        width: 40em;
        margin-left: -20em;
        position: absolute;
        top: 24em;
        left: 50%;
        font-size: 0.8em;
        background-color: rgba(32, 25, 19,0.5);
        background-image: none;
    }

    #playerList > div {
        width: 50%;
        float: left;
        border-right: 1px solid black;
        padding: 1em;
    }
    </style>
    <!-- Isogenic Loader -->
    <!-- <script type="text/javascript">var igeRoot = './ige/engine/';</script>
     <script type="text/javascript" src="./ige/engine/loader.js"></script>-->
    <script type="text/javascript" src="jquery-2.0.3.js"></script>
    <script type="text/javascript" src="jquery-ui-1.10.3.custom.js"></script>
    <script src='sounds/webaudiox.lineout.js'></script>
    <script src='sounds/webaudiox.loadbuffer.js'></script>
    <script src='sounds/webaudiox.three.js'></script>
    <script type="text/javascript">var igeRoot = './ige2912/engine/';</script>
    <script type="text/javascript" src="./ige2912/engine/loader.js"></script>

    <script type="x-shader/x-vertex" src="./shaders/terrain.vert" id="terrainvertexshader">
        #define PHONG
varying vec3 vViewPosition;
varying vec3 vNormal;
varying vec2 vUv;
varying float vHeight;
varying float vAngle;
uniform vec4 offsetRepeat;
#ifdef USE_LIGHTMAP
varying vec2 vUv2;
#endif
#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )
varying vec3 vReflect;
uniform float refractionRatio;
uniform bool useRefract;
#endif
#ifndef PHONG_PER_PIXEL
#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
varying vec4 vPointLight[ MAX_POINT_LIGHTS ];
#endif
#if MAX_SPOT_LIGHTS > 0
uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];
uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];
varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];
#endif
#endif
#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )
varying vec3 vWorldPosition;
#endif
#ifdef USE_COLOR
varying vec3 vColor;
#endif
#ifdef USE_MORPHTARGETS
#ifndef USE_MORPHNORMALS
uniform float morphTargetInfluences[ 8 ];
#else
uniform float morphTargetInfluences[ 4 ];
#endif
#endif
#ifdef USE_SKINNING
#ifdef BONE_TEXTURE
uniform sampler2D boneTexture;
uniform int boneTextureWidth;
uniform int boneTextureHeight;
mat4 getBoneMatrix( const in float i ) {
float j = i * 4.0;
float x = mod( j, float( boneTextureWidth ) );
float y = floor( j / float( boneTextureWidth ) );
float dx = 1.0 / float( boneTextureWidth );
float dy = 1.0 / float( boneTextureHeight );
y = dy * ( y + 0.5 );
vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
mat4 bone = mat4( v1, v2, v3, v4 );
return bone;
}
#else
uniform mat4 boneGlobalMatrices[ MAX_BONES ];
mat4 getBoneMatrix( const in float i ) {
mat4 bone = boneGlobalMatrices[ int(i) ];
return bone;
}
#endif
#endif
#ifdef USE_SHADOWMAP
varying vec4 vShadowCoord[ MAX_SHADOWS ];
uniform mat4 shadowMatrix[ MAX_SHADOWS ];
#endif
void main() {
    vUv = uv;// * offsetRepeat.zw + offsetRepeat.xy;
    #ifdef USE_LIGHTMAP
    vUv2 = uv2;
    #endif
    #ifdef USE_COLOR
    #ifdef GAMMA_INPUT
    vColor = color * color;
    #else
    vColor = color;
    #endif
    #endif
    #ifdef USE_MORPHNORMALS
    vec3 morphedNormal = vec3( 0.0 );
    morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
    morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
    morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
    morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
    morphedNormal += normal;
    #endif
    #ifdef USE_SKINNING
    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    #endif
    #ifdef USE_SKINNING
    mat4 skinMatrix = skinWeight.x * boneMatX;
    skinMatrix 	+= skinWeight.y * boneMatY;
    #ifdef USE_MORPHNORMALS
    vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );
    #else
    vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );
    #endif
    #endif
    vec3 objectNormal;
    #ifdef USE_SKINNING
    objectNormal = skinnedNormal.xyz;
    #endif
    #if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )
    objectNormal = morphedNormal;
    #endif
    #if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )
    objectNormal = normal;
    #endif
    #ifdef FLIP_SIDED
    objectNormal = -objectNormal;
    #endif
    vec3 transformedNormal = normalMatrix * objectNormal;
    vNormal = normalize( transformedNormal );
    #ifdef USE_MORPHTARGETS
    vec3 morphed = vec3( 0.0 );
    morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
    morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
    morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
    morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
    #ifndef USE_MORPHNORMALS
    morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
    morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
    morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
    morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
    #endif
    morphed += position;
    #endif
    #ifdef USE_SKINNING
    #ifdef USE_MORPHTARGETS
    vec4 skinVertex = vec4( morphed, 1.0 );
    #else
    vec4 skinVertex = vec4( position, 1.0 );
    #endif
    vec4 skinned  = boneMatX * skinVertex * skinWeight.x;
    skinned 	  += boneMatY * skinVertex * skinWeight.y;
    #endif
    vec4 mvPosition;
    #ifdef USE_SKINNING
    mvPosition = modelViewMatrix * skinned;
    #endif
    #if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )
    mvPosition = modelViewMatrix * vec4( morphed, 1.0 );
    #endif
    #if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )
    mvPosition = modelViewMatrix * vec4( position, 1.0 );
    #endif
    gl_Position = projectionMatrix * mvPosition;
    vViewPosition = -mvPosition.xyz;
    #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
    #ifdef USE_SKINNING
    vec4 worldPosition = modelMatrix * skinned;
    #endif
    #if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )
    vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );
    #endif
    #if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )
    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
    #endif
    #endif
    #if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )
    vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;
    worldNormal = normalize( worldNormal );
    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
    if ( useRefract ) {
    vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
    } else {
    vReflect = reflect( cameraToVertex, worldNormal );
    }
    #endif
    #ifndef PHONG_PER_PIXEL
    #if MAX_POINT_LIGHTS > 0
    for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
    vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
    vec3 lVector = lPosition.xyz - mvPosition.xyz;
    float lDistance = 1.0;
    if ( pointLightDistance[ i ] > 0.0 )
    lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
    vPointLight[ i ] = vec4( lVector, lDistance );
    }
    #endif
    #if MAX_SPOT_LIGHTS > 0
    for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {
    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );
    vec3 lVector = lPosition.xyz - mvPosition.xyz;
    float lDistance = 1.0;
    if ( spotLightDistance[ i ] > 0.0 )
    lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );
    vSpotLight[ i ] = vec4( lVector, lDistance );
    }
    #endif
    #endif
    #if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )
    vWorldPosition = worldPosition.xyz;
    #endif
    #ifdef USE_SHADOWMAP
    for( int i = 0; i < MAX_SHADOWS; i ++ ) {
    vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;
    }
    #endif

    vHeight = 0.5;//worldPosition.y;
    vAngle = 0.5;//acos(dot( vNormal , vec3(0,1.0,0)));
}
    </script>
    <script type="x-shader/x-fragment" src="./shaders/terrain.frag" id="terrainfragmentshader">
        uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;

uniform vec3 diffuse;
uniform float opacity;
uniform vec3 ambient;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;

varying float vHeight;
varying float vAngle;
const float PI_HALF = 3.141592653 / 2.0;

#ifdef USE_COLOR
varying vec3 vColor;
#endif
varying vec2 vUv;
#ifdef USE_MAP
uniform sampler2D map;
#endif
#ifdef USE_LIGHTMAP
varying vec2 vUv2;
uniform sampler2D lightMap;
#endif
#ifdef USE_ENVMAP
uniform float reflectivity;
uniform samplerCube envMap;
uniform float flipEnvMap;
uniform int combine;
#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
uniform bool useRefract;
uniform float refractionRatio;
#else
varying vec3 vReflect;
#endif
#endif
#ifdef USE_FOG
uniform vec3 fogColor;
#ifdef FOG_EXP2
uniform float fogDensity;
#else
uniform float fogNear;
uniform float fogFar;
#endif
#endif
uniform vec3 ambientLightColor;
#if MAX_DIR_LIGHTS > 0
uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];
uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];
#endif
#if MAX_HEMI_LIGHTS > 0
uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];
uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];
uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];
#endif
#if MAX_POINT_LIGHTS > 0
uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
#ifdef PHONG_PER_PIXEL
uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
uniform float pointLightDistance[ MAX_POINT_LIGHTS ];
#else
varying vec4 vPointLight[ MAX_POINT_LIGHTS ];
#endif
#endif
#if MAX_SPOT_LIGHTS > 0
uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];
uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];
uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];
uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];
uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];
#ifdef PHONG_PER_PIXEL
uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];
#else
varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];
#endif
#endif
#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )
varying vec3 vWorldPosition;
#endif
#ifdef WRAP_AROUND
uniform vec3 wrapRGB;
#endif
varying vec3 vViewPosition;
varying vec3 vNormal;
#ifdef USE_SHADOWMAP
uniform sampler2D shadowMap[ MAX_SHADOWS ];
uniform vec2 shadowMapSize[ MAX_SHADOWS ];
uniform float shadowDarkness[ MAX_SHADOWS ];
uniform float shadowBias[ MAX_SHADOWS ];
varying vec4 vShadowCoord[ MAX_SHADOWS ];
float unpackDepth( const in vec4 rgba_depth ) {
const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
float depth = dot( rgba_depth, bit_shift );
return depth;
}
#endif
#ifdef USE_BUMPMAP
uniform sampler2D bumpMap;
uniform float bumpScale;
vec2 dHdxy_fwd() {
vec2 dSTdx = dFdx( vUv );
vec2 dSTdy = dFdy( vUv );
float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
return vec2( dBx, dBy );
}
vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
vec3 vSigmaX = dFdx( surf_pos );
vec3 vSigmaY = dFdy( surf_pos );
vec3 vN = surf_norm;
vec3 R1 = cross( vSigmaY, vN );
vec3 R2 = cross( vN, vSigmaX );
float fDet = dot( vSigmaX, R1 );
vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
return normalize( abs( fDet ) * surf_norm - vGrad );
}
#endif
#ifdef USE_NORMALMAP
uniform sampler2D normalMap;
uniform vec2 normalScale;
vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
vec3 q0 = dFdx( eye_pos.xyz );
vec3 q1 = dFdy( eye_pos.xyz );
vec2 st0 = dFdx( vUv.st );
vec2 st1 = dFdy( vUv.st );
vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
vec3 N = normalize( surf_norm );
vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
mapN.xy = normalScale * mapN.xy;
mat3 tsn = mat3( S, T, N );
return normalize( tsn * mapN );
}
#endif
#ifdef USE_SPECULARMAP
uniform sampler2D specularMap;
#endif
void main() {
    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    vec4 water = (smoothstep(0.01, 0.25, vHeight) - smoothstep(0.24, 0.26, vHeight)) * texture2D( oceanTexture, vUv * 10.0 );
    vec4 sandy = (smoothstep(0.24, 0.27, vHeight) - smoothstep(0.28, 0.31, vHeight)) * texture2D( sandyTexture, vUv * 10.0 );
    float a = (vAngle-PI_HALF) / PI_HALF;
    vec4 rocky = (smoothstep(0.28, 0.32, vHeight) * (1.0 - smoothstep(0.01, 0.89, a))) 				* texture2D( rockyTexture, vUv * 20.0 );
    vec4 grass = (smoothstep(0.28, 0.32, vHeight) * smoothstep(0.01, 0.9, a)) 			* texture2D( grassTexture, vUv * 20.0 );
    vec4 texelColor = vec4(1.0, 0.0, 0.0, 1.0) + water + sandy + grass + rocky;

    #ifdef GAMMA_INPUT
    texelColor.xyz *= texelColor.xyz;
    #endif
    gl_FragColor = gl_FragColor * texelColor;

    #ifdef ALPHATEST
    if ( gl_FragColor.a < ALPHATEST ) discard;
    #endif
    float specularStrength;
    #ifdef USE_SPECULARMAP
    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;
    #else
    specularStrength = 1.0;
    #endif
    vec3 normal = normalize( vNormal );
    vec3 viewPosition = normalize( vViewPosition );
    #ifdef DOUBLE_SIDED
    normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );
    #endif
    #ifdef USE_NORMALMAP
    normal = perturbNormal2Arb( -vViewPosition, normal );
    #elif defined( USE_BUMPMAP )
    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
    #endif
    #if MAX_POINT_LIGHTS > 0
    vec3 pointDiffuse  = vec3( 0.0 );
    vec3 pointSpecular = vec3( 0.0 );
    for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {
    #ifdef PHONG_PER_PIXEL
    vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
    vec3 lVector = lPosition.xyz + vViewPosition.xyz;
    float lDistance = 1.0;
    if ( pointLightDistance[ i ] > 0.0 )
    lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );
    lVector = normalize( lVector );
    #else
    vec3 lVector = normalize( vPointLight[ i ].xyz );
    float lDistance = vPointLight[ i ].w;
    #endif
    float dotProduct = dot( normal, lVector );
    #ifdef WRAP_AROUND
    float pointDiffuseWeightFull = max( dotProduct, 0.0 );
    float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );
    vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );
    #else
    float pointDiffuseWeight = max( dotProduct, 0.0 );
    #endif
    pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;
    vec3 pointHalfVector = normalize( lVector + viewPosition );
    float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );
    float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );
    #ifdef PHYSICALLY_BASED_SHADING
    float specularNormalization = ( shininess + 2.0001 ) / 8.0;
    vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );
    pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;
    #else
    pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;
    #endif
    }
    #endif
    #if MAX_SPOT_LIGHTS > 0
    vec3 spotDiffuse  = vec3( 0.0 );
    vec3 spotSpecular = vec3( 0.0 );
    for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {
    #ifdef PHONG_PER_PIXEL
    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );
    vec3 lVector = lPosition.xyz + vViewPosition.xyz;
    float lDistance = 1.0;
    if ( spotLightDistance[ i ] > 0.0 )
    lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );
    lVector = normalize( lVector );
    #else
    vec3 lVector = normalize( vSpotLight[ i ].xyz );
    float lDistance = vSpotLight[ i ].w;
    #endif
    float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );
    if ( spotEffect > spotLightAngleCos[ i ] ) {
    spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );
    float dotProduct = dot( normal, lVector );
    #ifdef WRAP_AROUND
    float spotDiffuseWeightFull = max( dotProduct, 0.0 );
    float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );
    vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );
    #else
    float spotDiffuseWeight = max( dotProduct, 0.0 );
    #endif
    spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;
    vec3 spotHalfVector = normalize( lVector + viewPosition );
    float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );
    float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );
    #ifdef PHYSICALLY_BASED_SHADING
    float specularNormalization = ( shininess + 2.0001 ) / 8.0;
    vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );
    spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;
    #else
    spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;
    #endif
    }
    }
    #endif
    #if MAX_DIR_LIGHTS > 0
    vec3 dirDiffuse  = vec3( 0.0 );
    vec3 dirSpecular = vec3( 0.0 );
    for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( normal, dirVector );
    #ifdef WRAP_AROUND
    float dirDiffuseWeightFull = max( dotProduct, 0.0 );
    float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );
    vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );
    #else
    float dirDiffuseWeight = max( dotProduct, 0.0 );
    #endif
    dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;
    vec3 dirHalfVector = normalize( dirVector + viewPosition );
    float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );
    float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );
    #ifdef PHYSICALLY_BASED_SHADING
    float specularNormalization = ( shininess + 2.0001 ) / 8.0;
    vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );
    dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;
    #else
    dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;
    #endif
    }
    #endif
    #if MAX_HEMI_LIGHTS > 0
    vec3 hemiDiffuse  = vec3( 0.0 );
    vec3 hemiSpecular = vec3( 0.0 );
    for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {
    vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );
    vec3 lVector = normalize( lDirection.xyz );
    float dotProduct = dot( normal, lVector );
    float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;
    vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );
    hemiDiffuse += diffuse * hemiColor;
    vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );
    float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;
    float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );
    vec3 lVectorGround = -lVector;
    vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );
    float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;
    float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );
    #ifdef PHYSICALLY_BASED_SHADING
    float dotProductGround = dot( normal, lVectorGround );
    float specularNormalization = ( shininess + 2.0001 ) / 8.0;
    vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );
    vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );
    hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );
    #else
    hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;
    #endif
    }
    #endif
    vec3 totalDiffuse = vec3( 0.0 );
    vec3 totalSpecular = vec3( 0.0 );
    #if MAX_DIR_LIGHTS > 0
    totalDiffuse += dirDiffuse;
    totalSpecular += dirSpecular;
    #endif
    #if MAX_HEMI_LIGHTS > 0
    totalDiffuse += hemiDiffuse;
    totalSpecular += hemiSpecular;
    #endif
    #if MAX_POINT_LIGHTS > 0
    totalDiffuse += pointDiffuse;
    totalSpecular += pointSpecular;
    #endif
    #if MAX_SPOT_LIGHTS > 0
    totalDiffuse += spotDiffuse;
    totalSpecular += spotSpecular;
    #endif
    #ifdef METAL
    gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );
    #else
    gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;
    #endif
    #ifdef USE_LIGHTMAP
    gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );
    #endif
    #ifdef USE_COLOR
    gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );
    #endif
    #ifdef USE_ENVMAP
    vec3 reflectVec;
    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )
    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );
    if ( useRefract ) {
    reflectVec = refract( cameraToVertex, normal, refractionRatio );
    } else {
    reflectVec = reflect( cameraToVertex, normal );
    }
    #else
    reflectVec = vReflect;
    #endif
    #ifdef DOUBLE_SIDED
    float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );
    vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #else
    vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
    #endif
    #ifdef GAMMA_INPUT
    cubeColor.xyz *= cubeColor.xyz;
    #endif
    if ( combine == 1 ) {
    gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );
    } else if ( combine == 2 ) {
    gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;
    } else {
    gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );
    }
    #endif
    #ifdef USE_SHADOWMAP
    #ifdef SHADOWMAP_DEBUG
    vec3 frustumColors[3];
    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );
    frustumColors[1] = vec3( 0.0, 1.0, 0.8 );
    frustumColors[2] = vec3( 0.0, 0.5, 1.0 );
    #endif
    #ifdef SHADOWMAP_CASCADE
    int inFrustumCount = 0;
    #endif
    float fDepth;
    vec3 shadowColor = vec3( 1.0 );
    for( int i = 0; i < MAX_SHADOWS; i ++ ) {
    vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;
    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
    bool inFrustum = all( inFrustumVec );
    #ifdef SHADOWMAP_CASCADE
    inFrustumCount += int( inFrustum );
    bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );
    #else
    bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
    #endif
    bool frustumTest = all( frustumTestVec );
    if ( frustumTest ) {
    shadowCoord.z += shadowBias[ i ];
    #if defined( SHADOWMAP_TYPE_PCF )
    float shadow = 0.0;
    const float shadowDelta = 1.0 / 9.0;
    float xPixelOffset = 1.0 / shadowMapSize[ i ].x;
    float yPixelOffset = 1.0 / shadowMapSize[ i ].y;
    float dx0 = -1.25 * xPixelOffset;
    float dy0 = -1.25 * yPixelOffset;
    float dx1 = 1.25 * xPixelOffset;
    float dy1 = 1.25 * yPixelOffset;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );
    #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
    float shadow = 0.0;
    float xPixelOffset = 1.0 / shadowMapSize[ i ].x;
    float yPixelOffset = 1.0 / shadowMapSize[ i ].y;
    float dx0 = -1.0 * xPixelOffset;
    float dy0 = -1.0 * yPixelOffset;
    float dx1 = 1.0 * xPixelOffset;
    float dy1 = 1.0 * yPixelOffset;
    mat3 shadowKernel;
    mat3 depthKernel;
    depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
    depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
    depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
    depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
    depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
    depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
    depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
    depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
    depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
    vec3 shadowZ = vec3( shadowCoord.z );
    shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));
    shadowKernel[0] *= vec3(0.25);
    shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));
    shadowKernel[1] *= vec3(0.25);
    shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));
    shadowKernel[2] *= vec3(0.25);
    vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );
    shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );
    shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );
    vec4 shadowValues;
    shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );
    shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );
    shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );
    shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );
    shadow = dot( shadowValues, vec4( 1.0 ) );
    shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );
    #else
    vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );
    float fDepth = unpackDepth( rgbaDepth );
    if ( fDepth < shadowCoord.z )
    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );
    #endif
    }
    #ifdef SHADOWMAP_DEBUG
    #ifdef SHADOWMAP_CASCADE
    if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];
    #else
    if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];
    #endif
    #endif
    }
    #ifdef GAMMA_OUTPUT
    shadowColor *= shadowColor;
    #endif
    gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;
    #endif
    #ifdef GAMMA_OUTPUT
    gl_FragColor.xyz = sqrt( gl_FragColor.xyz );
    #endif
    #ifdef USE_FOG
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    #ifdef FOG_EXP2
    const float LOG2 = 1.442695;
    float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );
    fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );
    #else
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    #endif
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
    #endif
}
    </script>

    <script type="x-shader/x-vertex" id="grassvertexshader">

        uniform float zoom;

        attribute float atlasIndex;

        varying vec2 vUv;
        //varying float grassViewHeight;
        varying float viewHeight;

        const float imageSize = 128.0;
        const float imagesOnAtlas = 2.0;
        const float PI = 3.14159265358979323846264;

        void main() {

        float y = floor(atlasIndex / imagesOnAtlas);
        vUv = vec2( (atlasIndex - y * imagesOnAtlas) / imagesOnAtlas, y / imagesOnAtlas );

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		
		//if (length( mvPosition.xyz ) < 10.0) discard;

        viewHeight = cos(atan(abs(cameraPosition.y - position.y) / length(position.xz - cameraPosition.xz)));

        gl_PointSize = zoom * ( 180.0 / length( mvPosition.xyz ) );

        gl_Position = projectionMatrix * mvPosition;

        }

    </script>

    <script type="x-shader/x-fragment" id="grassfragmentshader">

        //uniform sampler2D grassAtlas;
        uniform sampler2D atlas;

        varying vec2 vUv;

        //varying float grassViewHeight;
        varying float viewHeight;

        const float imagesOnAtlas = 2.0;

        void main() {
            //if (gl_PointCoord.y < grassViewHeight) {
            if (gl_PointCoord.y < viewHeight) {
                gl_FragColor = texture2D(atlas, vec2( (gl_PointCoord.x / imagesOnAtlas) + vUv.s, ((gl_PointCoord.y / imagesOnAtlas) / viewHeight) + vUv.t ) );
                //gl_FragColor = texture2D(grassAtlas, vec2( (gl_PointCoord.x / imagesOnAtlas) + vUv.s, ((gl_PointCoord.y / imagesOnAtlas) / grassViewHeight) + vUv.t ) );
                //gl_FragColor = texture2D(grassAtlas, vUv );
            } else {
                gl_FragColor.r = 1.0;
                gl_FragColor.g = 1.0;
                gl_FragColor.b = 1.0;
                gl_FragColor.a = 0.0;
            }
        }

    </script>
</head>
<body oncontextmenu="return false;" onselect="return false;" onselectstart="return false;">

    <div id="backgroundimage"></div>

    <div class="igeLoading loadingFloat">
        <div class="loadingLogo"></div>
        <div class="loadingCircle"></div>
        <div class="loadingCircleInner"></div>
        <div class="loadingText" id="loadingText">
            Loading
        </div>
        <div id="loadingProgress">
            <div id="loadingProgressBar"></div>
        </div>
    </div>
    <div class="igeLoading loadingLink">
        Powered By Isogenic Game Engine
        <a href="http://www.isogenicengine.com" target="_blank">http://www.isogenicengine.com</a>
    </div>


    <div id="blocker">

        <div id="gameMenu">
            <li><a href="#" id="spawnLink" class="yellowText cantSpawn" onclick="javascript:UI.minimap.show()"><span class="ui-icon ui-icon-carat-1-e"></span>Spawn</a></li>
            <li><a href="#"><span class="ui-icon ui-icon-carat-1-e"></span>Start vote</a>
				<ul style="width: 140px;">
					<li><a href="#" onclick="javascript:ige.client.startVote('impeach')"><span class="ui-icon ui-icon-carat-1-e"></span>Impeach commander</a></li>
				</ul>
			</li>
            <li><a href="#" onclick="javascript:ige._player.takeCommander()"><span class="ui-icon ui-icon-carat-1-e"></span>Take Commander</a></li> <!-- class="ui-state-disabled" -->
            <li><a href="#" onclick="javascript:UI.options.openDialog()"><span class="ui-icon ui-icon-gear"></span>Options</a></li>
        </div>

        <div id="instructions" style="display: none;">
            <span style="font-size:40px">Click to play</span>
            <br />
            (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Punch)
        </div>

        <div id="options-dialog">
            <table>
                <tr><td>Your name:</td><td><input id="options_name" type="text" style="width: 150px;" /></td></tr>
                <tr><td>Sound:</td><td><button id="options_mute"></button></td></tr>
            </table>
        </div>

        <div id="minimap">

        </div>

        <div id="playerList" class="ui-widget-content ui-corner-all">
            <div>
                <span class="yellowText">Lizards:</span><br />
                <span class="playerListEntries"></span>
            </div>
            <div>
                <span class="yellowText">Meerkats:</span><br />
                <span class="playerListEntries"></span>
            </div>
        </div>

    </div>

    <div id="interface">

        <div id="statusbar">
            <img id="resourceFactionSingle" src="" />
            <span id="resource1_1">0</span> <img src="./assets/ui/icon_gold.png" />
            <span id="resource1_2">0</span> <img class="resource2Image" src="./assets/ui/icon_wood.png" />
            &nbsp;&nbsp;
            <img id="resourceFactionMultiple" src="" />
            <span id="resource2_1">0</span> <img src="./assets/ui/icon_gold.png" />
            <span id="resource2_2">0</span> <img class="resource2Image" src="./assets/ui/icon_wood.png" />

            <div id="voiceCommands">
                Voice Commands (V)
                <div>
                    1. Vie for attention<br />
                    2. Question, insecurity<br />
                    3. Warning shout<br />
                    4. Cry for help<br />
                    5. Excitement, panic<br />
                    6. Chatter<br />
                </div>
            </div>
        </div>
		
		<div id="vote-dialog" title="Impeach commander?">
		  <p></p>
		</div>

        <div id="blockbar" style="width: 126px; height: 40px;">
            <img src="./assets/ui/blockbar_outer.png" style="width: 100%; height: 100%;" />
            <div id="blockbarInner"></div>
        </div>

        <div id="stambar" style="width: 126px; height: 28px;">
            <img src="./assets/ui/stambar_outer.png" style="width: 100%; height: 100%;" />
            <div id="stambarInner"></div>
        </div>

        <div id="goldHarvestElement"></div>

        <div id="healthbar">
            <div id="healthbarInner" style="background-color: #FF3300;"></div>
            <img src="assets/ui/progressbarOverlay.png" />
        </div>

        <div id="buildMenu">
            <div class="spellSlot" style="background-image: url(./assets/ui/buildingLizardsMain.jpg);"><br />Outpost</div>
            <div class="spellSlot"><br />Refinery</div>
        </div>

        <div id="chat">
            <div id="chat-content"></div>
            <input id="chat-textinput" type="text" />
        </div>

        <div id="reviveCountdown">
            0
        </div>

        <div id="key_G">
            <div class="lightRay"></div>
            <div id="goldDonationBar">
                <div id="goldDonationBarOuter"></div>
                <img id="goldDonationBarInner" src="./assets/ui/loader.jpg" />
                <div id="goldDonationBarDescriptor"></div>
            </div>
            <img id="goldDonationGoldFlyElement" src="./assets/ui/icon_gold.png" />
        </div>
    </div>
</body>
</html>
<script type="text/javascript">
    var UI = {
        blockBar: {
            el: $('#blockbar'),
            currentWidth: 126,
            setPercent: function(percent) {
                if (percent < 100) {
                    this.el.css('opacity', 0.6);
                    if (this.opacityCounter) clearTimeout(this.opacityCounter);
                } else if(!this.opacityCounter && this.currentWidth != 126) {
                    this.opacityCounter = setTimeout(function() {
                        this.el.css('opacity', 0);
                        this.opacityCounter = undefined;
                    }.bind(this), 500);
                }
                this.currentWidth = 126/100*percent;
                $('#blockbarInner').css('width', this.currentWidth);
            }
        },
        stamBar: {
            el: $('#stambar'),
            currentWidth: 126,
            setPercent: function(percent) {
                if (percent < 100) {
                    this.el.css('opacity', 0.6);
                    if (this.opacityCounter) clearTimeout(this.opacityCounter);
                } else if(!this.opacityCounter && this.currentWidth != 126) {
                    this.opacityCounter = setTimeout(function() {
                        this.el.css('opacity', 0);
                        this.opacityCounter = undefined;
                    }.bind(this), 500);
                }
                this.currentWidth = 126/100*percent;
                $('#stambarInner').css('width', this.currentWidth);
            }
        },
        notifications: {
            displayHarvest: function(amount) {
                $('#goldHarvestElement')
                    .finish()
                    .html(amount)
                    .css('opacity', 1)
                    .animate({
                        'padding-top': 0,
                        'opacity': 0
                    },
                    200,
                    function() {
                        $('#goldHarvestElement').css('padding-top', '40px');
                    }
                );
            },
			commanderChange: function(val) {
                this._notify(val == false ? 'Your commander has resigned!' : 'Player "' + val + '" is your new commander!');
			},
            gameEnd: function(winner) {
                var el = this._notify('Victory for the ' + winner + '!', 10000);
                el.css({
                    'font-size': '4em',
                    'color': 'red',
                    'top': '30%'
                });

                /*function runBounce(el, count) {
                    el.animate({
                        'margin-top': '30px'
                    }, 500, 'easeInExpo', function() {
                        el.animate({
                            'margin-top': '0'
                        }, 500, 'easeOutExpo', function() {
                            if (count < 10) {
                                runBounce(el, count + 1);
                            }
                        });
                    });
                }

                runBounce(el, 0);*/
                el.effect( "bounce", 1200 );
            },
            _notify: function(text, duration) {
                var el = $('<div class="generalNotificationElement">' + text + '</div>')
                        .css('opacity', 1).appendTo('#interface');

                setTimeout(function() {
                    this.animate({
                            'padding-top': 0,
                            'opacity': 0
                        },
                        1000,
                        function() {
                            this.remove();
                        }.bind(this)
                    );
                }.bind(el), duration ? duration : 2000);

                return el;
            }
        },
        healthBar: {
            //health will be sent with commands, not streamed. Health regen is done by periodicals both on server and client. Only heals and dmgs are sent and informed about.
            el: $('#healthbarInner'),
            maxvalue: 300,
            setValue: function(value) {
                this.el.css('width', 240/this.maxvalue*value).html(Math.round(value));
            }
        },
		buildingMenu: {
			displayPressed: function(key, isPressed) {
                if (isPressed) {
				    $('#buildMenu div:nth-child('+key+')').addClass('spellSlotPressed');
                } else {
                    $('#buildMenu div:nth-child('+key+')').removeClass('spellSlotPressed');
                }
			},
            display: function(isDisplayed) {
                $('#buildMenu').css('display', isDisplayed ? 'block' : 'none');
            }
		},
        voiceCommands: {
            display: function(isDisplayed) {
                $('#voiceCommands > div').css('display', isDisplayed ? 'block' : 'none');
            }
        },
		voting: {
			openDialog: function(data) {
				var title = '', text = '', no = 'No (F2)', yes = 'Yes (F3)',
					onNo = function(){}, onYes = function(){};
				switch (data.t) {
					case 'impeach':
						title = data.p + ' requests an impeach!';
						text = 'Should the current commander be relieved from his burden?';
						onNo = function() {
							$( this ).dialog( "close" );
						};
						onYes = function() {
							$( this ).dialog( "close" );
						};
					break;
				}
		
				$( "#vote-dialog" ).dialog({
					resizable: false,
					height: "auto",
					modal: false,
					title: title,
					buttons: {
						"No (F2)": onNo,
						"Yes (F3)": onYes
					}
				})
				.dialog("open")
				.children('p')
				.html(text);
			}
		},
        options: {
            openDialog: function() {
                $( "#options-dialog" ).dialog("open");
            },
            sound: true
        },
		resources: {
			setResource: function(nr, amount) {
				$('#resource1_'+nr).html(amount);
			},
            setResourceTeam: function(nr, amount) {
                $('#resource2_'+nr).html(amount);
            },
            _displayAddResourceAnimation: function(nr, amount) {
                //put green + sign
                var plusEl = $('<div class="resourceAddAnimElement" style="top: 30px;"></div>');
                plusEl.html('+' + amount);
                plusEl.animate({
                            opacity: 0.2,
                            top: 0
                        },
                        {
                            'duration': 2000,
                            'complete': function() {
                                $( this ).remove();
                            }
                        });
                $('#resource1_'+nr).append(plusEl);
            },
            _displayAddResourceTeamAnimation: function(nr, amount) {
                //put green + sign
                var plusEl = $('<div class="resourceAddAnimElement" style="top: 30px;"></div>');
                plusEl.html('+' + amount);
                plusEl.animate({
                            opacity: 0.2,
                            top: 0
                        },
                        {
                            'duration': 2000,
                            'complete': function() {
                                $( this ).remove();
                            }
                        });
                $('#resource2_'+nr).append(plusEl);
            },
            setFactionImages: function(faction) {
                $('#resourceFactionSingle').attr('src', './assets/ui/'+faction+'Head_single.png');
                $('#resourceFactionMultiple').attr('src', './assets/ui/'+faction+'Head_multiple.png');
                $('.resource2Image').attr('src', './assets/ui/icon_'+(faction == 'meerkats' ? 'wood' : 'stone')+'.png');
            },
            setKeyPressed: function(id, pressed) {
                $('#'+id).css('background-image', 'url(./assets/ui/key_G_'+(pressed ? '' : 'un')+'pressed.png)');
            },
            startKeyAnimations: function() {
                var els = $('.lightRay');
                this._keyAnimationCount = 0;

                for (var x = 0; x < els.length; x++) {
                    if ($(els[x]).children().length == 0) {
                        $(els[x]).append('<div></div><div style="background-position: 39px 0px;"></div><div style="background-position: 78px 0px;"></div>');
                    }
                }

                var properties = {duration: 600, easing: 'linear'};

                this._keyAnimationInterval = setInterval(function() {
                    this._keyAnimationCount = (this._keyAnimationCount+1) % 3;
                    for (var x = 0; x < els.length; x++) {
                        var lightEls = $(els[x]).children();
                        $(lightEls[this._keyAnimationCount]).fadeOut(properties);
                        $(lightEls[(this._keyAnimationCount + 1) % 3]).fadeIn(properties);
                    }
                }.bind(this), properties.duration);
            },
            stopKeyAnimations: function() {
                clearInterval(this._keyAnimationInterval);
            },
            setGoldDonationPercentage: function(percent, value) {
                if (percent == 0) {
                    $('#goldDonationBar').css('display', 'none');
                } else {
                    $('#goldDonationBar').css('display', 'block');
                    $('#goldDonationBarInner').css('width', percent + '%');
                    $('#goldDonationBarDescriptor').html(value).css('left', percent + '%');
                }
            },
            _goldFlyAnimFunc: function() {
                //make gold fly over
                $('#goldDonationGoldFlyElement')
                        .css('visibility', 'visible')
                        .animate({
                            left: this._teamGoldElementOffset.left,
                            top: this._teamGoldElementOffset.top
                        },
                        {
                            'duration': 180,
                            'complete': function() {
                                $( this).css('visibility', 'hidden')
                                        .css('top', '0px')
                                        .css('left', '0px');
                            }
                        });
            },
            _donationAnimFunc: function() {
                this._donationCount++;
                $('#goldDonationBarDescriptor').animate({
                            'font-size': this._donationCount % 2 == 1 ? '1.5em' : '1em'
                        },
                        {
                            'duration': 200,
                            'complete': this._donationCount % 2 == 0 ? undefined : this._goldFlyAnimFunc.bind(this)
                        });

                if (this._donationCount == 6) {
                    clearInterval(this._donationAnimInterval);
                }
            },
            makeDonation: function(value) {
                $('#goldDonationBarDescriptor').html(value);
                var offset = $('#goldDonationGoldFlyElement').offset();
                this._teamGoldElementOffset = $('#resource2_1').offset();
                this._teamGoldElementOffset.left -= offset.left;
                this._teamGoldElementOffset.top -= offset.top;
                console.log(this._teamGoldElementOffset);
                this._donationCount = 0;
                this._donationAnimFunc();
                this._donationAnimInterval = setInterval(this._donationAnimFunc.bind(this), 200);

                this._displayAddResourceTeamAnimation(1, value);
            }
		},
        spawn: {
            _reviveInterval: undefined,
            dying: function(reviveTimeout) {
                var reviveCount = reviveTimeout;
                var reviveEl = $('#reviveCountdown').css('display', 'block').html(reviveCount);
                this._reviveInterval = setInterval(function() {
                    reviveCount--;
                    if (reviveCount > 0) {
                        reviveEl.html(reviveCount);
                    } else {
                        this.goToSpawnScreen();
                    }
                }.bind(this), 1000);
            },
            _cancelDying: function() {
                clearInterval(this._reviveInterval);
                $('#reviveCountdown').css('display', 'none');
            },
            goToSpawnScreen: function() {
                this._cancelDying();
                document.exitPointerLock();
                UI.minimap.show();
                UI.spawn.canSpawn(true);
            },
            setInstructionsVisibility: function(isVisible) {
                $('#instructions').css('display', isVisible ? 'block' : 'none');
            },
            canSpawn: function(canSpawn) {
                if (canSpawn) {
                    $('#spawnLink').removeClass('cantSpawn');
                } else {
                    $('#spawnLink').addClass('cantSpawn');
                }
            }
        },
        minimap: {
            levelDimensions: 0,
            setBuilding: function(id, x, y) {
                var buildingMinimapElement = $('#minimapBuilding' + id);
                if (buildingMinimapElement.length == 0) {
                    buildingMinimapElement = $('<div id="minimapBuilding' + id + '" class="minimapBuilding"></div>');
                    buildingMinimapElement.on('click', this.selectBuilding);
                    $('#minimap').append(buildingMinimapElement);
                }
                buildingMinimapElement
                        .css('left', (x + this.levelDimensions / 2) / this.levelDimensions * 400 - 10)
                        .css('top', (y + this.levelDimensions / 2) / this.levelDimensions * 400 - 10);
            },
            selectBuilding: function() {
                ige._player.spawn(this.id.substring(15));
                $('body>canvas').css('display','block');
            },
            hide: function() {
                $('#minimap').css('display', 'none');
            },
            show: function() {
                if (!ige._player.states.isSpawned) {
                    $('#minimap').css('display', 'block');
                }
            }
        },
        chat: {
            _focused: false,
            focus: function() {
                $('#chat-textinput').focus();
                $('#chat').addClass('chat-focused');
                ige.client.controls.enabled = false;
                this._focused = true;
            },
            blur: function() {
                $('#chat-textinput').blur();
                $('#chat').removeClass('chat-focused');
                ige.client.controls.enabled = true;
                this._focused = false;
            },
            toggleFocus: function() {
                if (this._focused) {
                    var chatEl = $('#chat-textinput')[0];
                    var chatEntry = chatEl.value;
                    if (chatEntry.length > 0) {
                        ige.network.send('playerSendChatMessage', {type: 'team', text: chatEntry});
                        chatEl.value = '';
                    }
                    this.blur();
                } else {
                    this.focus();
                }
            },
            addMessage: function(type, playerName, text) {
                $('#chat-content').append(playerName + ": " + text + '<br />');
            }
        },
        playerList: {
            set: function(list) {
                var divs = $('#playerList .playerListEntries');
                $(divs[0]).html(list[0].join('<br />'));
                $(divs[1]).html(list[1].join('<br />'));
            }
        },
        igeLoadedFunctions: function() {

            ige.client.vp1.on('pointerLockEntered', function() {
                console.log('blocker gone2');
                blocker.style.display = 'none';
            });

            ige.client.vp1.on('pointerLockLeft', function() {

                blocker.style.display = '-webkit-box';
                blocker.style.display = '-moz-box';
                blocker.style.display = 'box';

                instructions.style.display = '';

                if (UI.spawn._reviveInterval != undefined) UI.spawn.goToSpawnScreen();
            });

        }
    };

    $(function() {

        UI.resources.startKeyAnimations();

        $( "#gameMenu" ).menu();
        $.each($('#buildMenu div.spellSlot'), function(index, el) {
            $(el).append('<span class="keyShortcutLabel">'+(index + 1)+'</span>');
        });

        $( "#options-dialog" ).dialog({
            resizable: false,
            height: "auto",
            modal: false,
            title: "Options",
            appendTo: "#blocker",
            buttons: {
                "Close": function() {
                    $( this ).dialog( "close" );

                    var playerName = $('#options_name')[0].value;
                    if (ige._player && ige._player.values.name != playerName) {
                        ige.network.send('playerRequestNameChange', playerName);
                    }
                }
            }
        })
        .dialog("close");

        $("#options_mute").button({
            label: "Unmute",
            icons: {
                primary: "ui-icon-volume-on"
            }
        }).on('click', function() {
            if (ige.client._sound) {
                $(this).button({
                    label: UI.options.sound ? "Muted" : "Unmuted2",
                    icons: {
                        primary: "ui-icon-volume-" + (UI.options.sound ? "off" : "on")
                    }
                });
                ige.client._sound.lineOut.toggleMute();
                UI.options.sound = !UI.options.sound;
            }
        });
    });

</script>